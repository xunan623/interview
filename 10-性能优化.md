##性能优化

1. App启动过程
2. APP启动优化
3. 安装包瘦身
4. RunLoop与NSTimer
5. RunLoop与多线程

****

###App启动过程

1. 冷启动(从零开始启动App)
2. 热启动(App已经在内存中,在后台存活,再次点击图标启动App)


查看启动时间:

Edit Scheme -> Arguments-> Environment  DYLD_PRINT_STATISTICS  1

DYLD_PRINT_STATISTICS : 更详细的时间信息

三个阶段:
	
1. dyld(dynamic link editor)Apple的动态链接器,可以用来装载Mach-O(可执行文件, 动态库等)	
	1. 装载App的可执行文件,同时会递归加载所有依赖的动态库
	2. 当dyld把可执行文件,动态库装载完毕后,会通知RunTime进行下一步处理
2. runtime
	
	1. 调用map_images进行可执行文件内容的解析和处理
	2. 在load_images中调用call_load_methods,调用所有Class和Category的+load方法
	3. 进行各种objc结构的初始化(注册Objc类,初始化类对象等等)
	4. 调用C++静态初始化器和__attribute__((constructor))修饰的函数
	5. 到现在,可执行文件和动态库中所有的符号(Class, Protocol, Selector, IMP...)都已经按格式成功加载到内存中,被runtime管理
3. main
	1. ApplicationMain函数

###App启动优化

按照不同的阶段:
	
	dyld:
	1. 减少动态库,合并一些动态库(定期清理不必要的动态库)
	2. 减少Objc类,分类的数量,减少Selector数量(定期清理不必要的类,分类)
	3. 减少C++虚函数的数量
	4. Swift尽量使用结构体
	RunTime阶段:
	1. 用+initialize方法和dispatch_once取代所有的__attribute__((constructor)),C++静态构造器,Objc的+load
	main函数:
	1. 按需加载.在不影响用户体验的前提下,尽可能将一些操作延迟,不要全部都放在finishLaunching方法中

###安装包瘦身

安装包(IPA)主要由可执行文件,资源组成

资源(图片,音频,视频等):
[](https://github.com/tinymind/LSUnusedResources)

	1. 采取无损压缩
	2. 去除没有用到的资源: 
可执行文件:

[](https://www.jetbrains.com/objc/)

	1. .编译器优化.Strip Linked Product, MakeStrings Read-Only, Symbols Hidden by Default设置为YES
	2. 去掉异常支持,Enable C++ Execptions, Enable Objective-C Exceptions设置为NO, Other C Flags添加-fno-exceptions
	3. 检查未使用的代码:菜单栏->Code->Inspect Code
	4. 生成LinkMap文件,可以查看可执行文件具体组成
		[](https://github.com/huanxsd/LinkMap/)

		
		










		