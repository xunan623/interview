###算法

![算法相关](https://raw.githubusercontent.com/xunan623/xunan623.github.io/master/算法/算法相关.png)

1. 字符串反转
2. 链表反转
3. 有序数组合并
4. Hash算法
5. 查找两个子视图的共同父视图
6. 求无序数组当中的中位数

****

##Java算法韩顺平

1. 生成二维数组(稀疏数组)
2. 数组模拟队列(环形队列)
3.   链表


**给定字符串 "hello,world",实现将其反转,输出 "dlrow,olleh"**

    // 指向第一个字符
    char *begin = cha;
    // 指向最后一个字符
    char *end = cha + strlen(cha) - 1;
    while (begin < end) {
        // 交换前后两个字符,同时移动指针
        char temp = *begin;
        *(begin++) = *end;
        *(end--) = temp;
    }

**链表反转**

![链表反转](https://raw.githubusercontent.com/xunan623/xunan623.github.io/master/算法/链表反转.png)

反转思想

![解链表反转思想](https://raw.githubusercontent.com/xunan623/xunan623.github.io/master/算法/链表反转思路.png)

**有序数组合并**

[1, 4, 6, 7 ,9] + [2, 3, 5, 6, 8, 10, 11, 12] 

=>

[1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12]

解题思路

![合并思路](https://raw.githubusercontent.com/xunan623/xunan623.github.io/master/算法/有序数组合并.png)

答案: 

	// 定义遍历指针,初始化为头结点
    struct Node *p = head;
    // 反转后的链表头部
    struct Node *newH = NULL;
    
    // 遍历链表
    while (p != NULL) {
        // 记录下一个结点
        struct Node *temp = p->next;
        // 当前结点的next指向新链表的头部
        p->next = newH;
        // 更改新链表头部为当前结点
        newH = p;
        // 移动p指针
        p = temp;
    }
    
    // 返回反转后的链表头结点
    return newH;

		
**Hash算法**

![Hash图解](https://raw.githubusercontent.com/xunan623/xunan623.github.io/master/算法/哈希查找.png)

**问: 在一个字符串中找到第一个只出现一次的字符?**

如: 输入"abaccdeff",则输出: b

算法思路

字符(char)是一个长度为8的数据类型,因此总共有可能256种可能.

每个字符根据其ASCII码值作为数组的下标对应数组的一个数字.

数组中存储的是每个字符出现的次数.

答案:
		    
	char result = '\0';
    // 定义一个数组 用来存储各个字母出现次数
    int array[256];
    // 对数组进行初始化操作
    for (int i = 0 ; i < 256; i++) {
        array[i] = 0;
    }
    // 定义一个指针,只想当前字符串头部
    char* p = cha;
    // 遍历每个字符
    while (*p != '\0') {
        // 在字母对应存储位置 进行出现次数+1操作
        array[*(p++)]++;
    }
    
    // 将P指针重新指向字符串头部
    p = cha;
    // 遍历每个字母的出现次数
    while (*p != '\n') {
        // 遇到第一个出现次数为1的字符,打印结果
        if (array[*p] == 1) {
            result = *p;
            break;
        }
        // 反之极限向后遍历
        p++;
    }
    
    return result;

**查找两个子视图的共同父视图**

算法思路:

![查找两个子视图的父视图思路](https://raw.githubusercontent.com/xunan623/xunan623.github.io/master/算法/两个子视图的共同父视图.png)

答案:
		    NSMutableArray *result = [NSMutableArray array];
    
    // 查找第一个视图的所有父视图
    NSArray *arrayOne = [self findSuperViews:viewOne];

    // 查找第二个视图的所有父视图
    NSArray *arrayOther = [self findSuperViews:viewOther];
    
    int i = 0;
    
    // 越界限制条件
    while (i < MIN((int)arrayOne.count, (int)arrayOther.count)) {
        // 倒序方式获取各个视图的父视图
        UIView *superOne = [arrayOne objectAtIndex:arrayOne.count - i - 1];
        UIView *superOther = [arrayOther objectAtIndex:arrayOther.count - i - 1];
        
        // 比较如果相等 则为共同父视图
        if (superOne == superOther) {
            [result addObject:superOne];
            i++;
        }
        // 如果不相等,则结束遍历
        else {
            break;
        }
    }

    return result;

	- (NSArray<UIView *> *)findSuperViews:(UIView *)view {
    
	    // 初始化第一个父视图
	    UIView *temp = view.superview;
	    // 保存结果的数组
	    NSMutableArray *result = [NSMutableArray array];
	    while (temp) {
	        [result addObject:temp];
	        // 顺着superview指针一直往上查找
	        temp = temp.superview;
	    }
	    return result;
	}

**求无序数组当中的中位数**

1. 排序算法+中位数
	
	排序算法:冒泡排序,快速排序,堆排序...
	中位数: 当n为奇数时: (n+1)/2 当n为偶数时: (n/2 + (n/2 + 1))/2

2. 利用快排思想(分治思想)
	
	1.选取关键字,高低交替扫描
	
	![图解](https://raw.githubusercontent.com/xunan623/xunan623.github.io/master/算法/快排思想.png)

	2.任意挑选一个元素,以该元素为支点,划分集合为两部分
	
	如果左侧集合长度恰好为(n-1)/2, 那么支点恰为中位数.
	
	如果左侧长度<(n-1)/2,那么中位点在右侧;反正,中位数在左侧.
	
	进入相应的一侧继续寻找中位点
	
	

****


##Java算法韩顺平

1. 生成二维数组, 并将二维数组转稀疏数组

		int chessArr1[][] = new int[11][11];
		chessArr1[1][2] = 1;
		chessArr1[2][3] = 2;
		for (int[] row : chessArr1) {
			for (int[] data: row) {
				System.out.printf("%d\t", data);
			}
		}
		
		// 1.先遍历二维数组 得到非0数据的个数
		int sum = 0;
		int n = chessArr1.length, m = chessArr1[0].length;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (chessArr1[i][j] != 0) {
					sum++;
				}
			}
		}
		
		// 2.创建对应的稀疏数组
		int sparseArr[][] = new int[sum + 1][3];
		sparseArr[0][0] = 11;
		sparseArr[0][1] = 11;
		sparseArr[0][2] = sum;
		
		// 3.遍历二维数组, 将非0的值存放到稀疏数组(sparseArr)中
		int count = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (chessArr1[i][j] != 0) {
					count ++;
					sparseArr[count][0] = i;
					sparseArr[count][1] = j;
					sparseArr[count][2] = chessArr1[i][j];
				}
			}
		}
		
		// 输出
		for (int i = 0; i < sparseArr.length; i ++) {
			System.out.printf("%d \t %d \t %d \t \n", sparseArr[0], sparseArr[1], sparseArr[2]);
		}
		
		// 稀疏数组还原二维数据
		
		// 1.先读取稀疏数组的第一行
		
		int chessArr2[][] = new int[sparse[0][0]][sparse[0][1]];

		// 2. 从第二行读取
		for (int i = 1; i < sparseArr.length; i++) {
			chessArr2[sparseArr[i][0]][sparse[i][1]] = sparseArr[i][2];
		}
		
2. 数组模拟队列 

	1. front指向0
	2.  rear变量初始值为0, reer指向队列的最后一个元素的后一个位置
	3. 队列满的条件 (rear + 1) % maxSize == front 
	4. 队列为空 rear == front 
	5. 队列中有效数据的个数 **(rear + maxSize - front) % maxSize**

			class CircleQueue {
				private int maxSize; // 数组的最大容量
				private int front; // 队列头
				private int rear; // 队列尾
				private int[] arr;	// 数组
			
				// 队列构造器
				public CircleQueue(int arrMaxSize) {
					maxSize = arrMaxSize;
					arr = new int[maxSize];
				}
		
				// 队列是否已经满
				public boolean isFull() {
					return (rear + 1) % maxSize == front;
				}
				
				// 队列是否为空
				public boolean isEmpty() {  
					return rear == front;
				}
				
				public void addQueue(int n) {
					if (isFull()) {
						return;
					}
					arr[rear] = n;
					rear = (rear + 1) % maxSize;
				}
				
				// 获取队列的数据, 出队列
				public int getQueue() {
					
					if (isEmpty()) {
						throw new RuntimeException("队列为空, 不能取出");
					}
					// 这里需要分析出front是指向队列的第一个元素
					// 1. 先将front 对应的值保留到一个临时变量
					// 2. 将front后移, 考虑取模
					// 3. 将临时保存的变量返回
					int value = arr[front];
					front = (front + 1) % maxSize;
					return value;
				}
				
				// 显示队列的所有数据
				public void showQueue() {
					if (isEmpty()) {
						System.out.printIn("队列为空");
						return;
					}
					// 思路: 从front开始遍历, 遍历多少个元素
					for (int i = front; i < front + size(); i++) {
						System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
					}
				}
				
				// 当前队列有效数据的个数
				public int size() {
					return (rear + maxSize - front) % maxSize;
				}
			
				// 显示队列头数据
				public int headQueue() { 
					if (isEmpty()) {
						throw new RuntimeException("队列为空");
					}
					return arr[front];
				}
		    }
		
3. 链表
	
	思路
	
	1.先创建一个head头节点, 作用就是表示单链表的头
	
	2.后面我们每添加一个节点,就直接加入到链表的最后
	
	遍历:
	
	通过一个辅助变量遍历, 帮助遍历整个链表
	
	按照编号顺序添加:
	
	1.首先声明一个辅助变量,找到添加节点的位置, 遍历
	
	2.新的节点.next = temp.next
	
	3.将temp.next = 指向新的节点 
	
		public void test() {
			HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
			HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
			HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
			HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
			
			// 创建一个链表
			SingleLinkedList singleLinkedList = new SingleLinkedList();
			singleLinkedList.add(hero1);
			singleLinkedList.add(hero2);
			singleLinkedList.add(hero3);
			singleLinkedList.add(hero4);
		}
		
		定义SingleLinkedList 管理我们的英雄
		class SingleLinkedList {
			// 先初始化一个头结点, 头结点不要动, 不存放具体的数据
			private HeroNode head = new HeroNode(0, "", "");
			
			// 添加节点到单向链表
			// 思路, 当不考虑编号顺序时
			// 1. 找到当前链表的最后节点
			// 2.将最后这个节点的next, 指向新的节点
			public void add(HeroNode heroNode) {
				
				// 因为head节点不能动, 因此我们需要一个辅助遍历temp
				HeroNode temp = head;
				// 遍历链表, 找到最后
				while (true) {
					// 找到链表的最后
					if (temp.next == null) {
						break;
					}
					// 如果没有找到最后, 将temp后移
					temp = temp.next;
				}
			}
			
			// 第二种添加英雄时, 需要插入制定的位置(如果有这个排名, 则添加失败,并给出提示)
			
			
			// 显示链表[遍历]
			public void list() {
				// 判断链表是否为空
				if (head.next == null) {
					System.out.println("链表为空");
					return;
				}
				// 因为头节点不能动, 因此我们需要一个辅助变量来遍历
				HeroNode temp = head.next;
				while (true) {
					if (temp == null) {
						break;
					}
					System.out.println(temp);
					temp = temp.next;
				}
			}
		}
	
		// 定义HeroNode, 每个HeroNode对象就是一个节点
		class HeroNode {
			public int no;
			public String name;
			public String nickname;
			public HeroNode next; // 指向下一个节点
			// 构造器
			public HeroNode(int no, String name, String nickname) {
				this.no = no;
				this.name = name;
				this.nickname = nickname;
			}
		}
		
		